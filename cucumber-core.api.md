## API Report File for "@cucumber/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Argument } from '@cucumber/cucumber-expressions';
import { CucumberExpression } from '@cucumber/cucumber-expressions';
import { Envelope } from '@cucumber/messages';
import { GherkinDocument } from '@cucumber/messages';
import { Hook } from '@cucumber/messages';
import { IdGenerator } from '@cucumber/messages';
import { NamingStrategy } from '@cucumber/query';
import parse from '@cucumber/tag-expressions';
import { Pickle } from '@cucumber/messages';
import { RegularExpression } from '@cucumber/cucumber-expressions';
import { SourceReference } from '@cucumber/messages';
import { StepDefinition } from '@cucumber/messages';
import { TestCase } from '@cucumber/messages';
import { TestStep } from '@cucumber/messages';

// @public
export class AmbiguousError extends Error {
    constructor(text: string, references: ReadonlyArray<SourceReference>);
}

// @public
export interface AssembledTestCase {
    id: string;
    name: string;
    sourceReference: SourceReference;
    testSteps: ReadonlyArray<AssembledTestStep>;
    toMessage(): TestCase;
}

// @public
export interface AssembledTestPlan {
    name?: string;
    testCases: ReadonlyArray<AssembledTestCase>;
    toEnvelopes(): ReadonlyArray<Envelope>;
}

// @public
export interface AssembledTestStep {
    always: boolean;
    id: string;
    name: {
        prefix: string;
        body: string;
    };
    prepare(thisArg?: unknown): PreparedFunction;
    sourceReference: SourceReference;
    toMessage(): TestStep;
}

// @public
export function buildSupportCode(options?: SupportCodeOptions): SupportCodeBuilder;

// @public
export class DataTable {
    constructor(cells: ReadonlyArray<ReadonlyArray<string>>);
    hashes(): ReadonlyArray<Record<string, string>>;
    list(): ReadonlyArray<string>;
    raw(): ReadonlyArray<ReadonlyArray<string>>;
    rows(): ReadonlyArray<ReadonlyArray<string>>;
    rowsHash(): Record<string, string>;
    transpose(): DataTable;
}

// @public
export type DefinedParameterType = {
    id: string;
    name: string;
    regularExpressions: ReadonlyArray<string>;
    preferForRegularExpressionMatch: boolean;
    useForSnippets: boolean;
    sourceReference: SourceReference;
};

// @public
export type DefinedStep = {
    id: string;
    expression: {
        raw: string | RegExp;
        compiled: CucumberExpression | RegularExpression;
    };
    fn: SupportCodeFunction;
    sourceReference: SourceReference;
    toMessage(): StepDefinition;
};

// @public
export type DefinedTestCaseHook = {
    id: string;
    name?: string;
    tags?: {
        raw: string;
        compiled: ReturnType<typeof parse>;
    };
    fn: SupportCodeFunction;
    sourceReference: SourceReference;
    toMessage(): Hook;
};

// @public
export type DefinedTestRunHook = {
    id: string;
    name?: string;
    fn: SupportCodeFunction;
    sourceReference: SourceReference;
    toMessage(): Hook;
};

// @public
export function makeTestPlan(ingredients: TestPlanIngredients, options?: TestPlanOptions): AssembledTestPlan;

// @public
export type MatchedStep = {
    def: DefinedStep;
    args: ReadonlyArray<Argument>;
};

// @public
export interface NewParameterType {
    name: string;
    preferForRegexpMatch?: boolean;
    regexp: RegExp | string | readonly RegExp[] | readonly string[];
    sourceReference: SourceReference;
    transformer?: (...match: string[]) => unknown;
    useForSnippets?: boolean;
}

// @public
export interface NewStep {
    fn: SupportCodeFunction;
    pattern: string | RegExp;
    sourceReference: SourceReference;
}

// @public
export interface NewTestCaseHook {
    fn: SupportCodeFunction;
    name?: string;
    sourceReference: SourceReference;
    tags?: string;
}

// @public
export interface NewTestRunHook {
    fn: SupportCodeFunction;
    name?: string;
    sourceReference: SourceReference;
}

// @public
export type PreparedFunction = {
    fn: SupportCodeFunction;
    args: ReadonlyArray<unknown>;
};

// @public
export interface SupportCodeBuilder {
    afterAllHook(options: NewTestRunHook): SupportCodeBuilder;
    afterHook(options: NewTestCaseHook): SupportCodeBuilder;
    beforeAllHook(options: NewTestRunHook): SupportCodeBuilder;
    beforeHook(options: NewTestCaseHook): SupportCodeBuilder;
    build(): SupportCodeLibrary;
    parameterType(options: NewParameterType): SupportCodeBuilder;
    step(options: NewStep): SupportCodeBuilder;
}

// @public
export type SupportCodeFunction = (...args: any[]) => any | Promise<any>;

// @public
export interface SupportCodeLibrary {
    findAllAfterHooksBy(tags: ReadonlyArray<string>): ReadonlyArray<DefinedTestCaseHook>;
    findAllBeforeHooksBy(tags: ReadonlyArray<string>): ReadonlyArray<DefinedTestCaseHook>;
    findAllStepsBy(text: string): ReadonlyArray<MatchedStep>;
    getAllAfterAllHooks(): ReadonlyArray<DefinedTestRunHook>;
    getAllBeforeAllHooks(): ReadonlyArray<DefinedTestRunHook>;
    toEnvelopes(): ReadonlyArray<Envelope>;
}

// @public
export interface SupportCodeOptions {
    newId?: IdGenerator.NewId;
}

// @public
export interface TestPlanIngredients {
    gherkinDocument: GherkinDocument;
    pickles: ReadonlyArray<Pickle>;
    supportCodeLibrary: SupportCodeLibrary;
    testRunStartedId?: string;
}

// @public
export interface TestPlanOptions {
    newId?: IdGenerator.NewId;
    strategy?: NamingStrategy;
}

// @public
export class UndefinedError extends Error {
    constructor(text: string);
}

// @public
export type UndefinedParameterType = {
    name: string;
    expression: string;
};

// (No @packageDocumentation comment for this package)

```
